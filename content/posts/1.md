---
title: "Vue 3.3 generics and conditional properties"
description: "Use Vue 3.3 generics to change one property based on the value of another."
category: Vue.js
author: jeroenbach
date: 2024-10-09
imgCoverUrl: /posts/1/cover.jpeg
readTime: 10 min
---

I wanted to improve the usability of the MultiSelect, making it smarter and understand that I'm returning an array when I specified _multiple_ and a single item when I didn't. Read further on how I've managed to do this leveraging generics in Vue 3.3. Generics allowed me change a property type based on another property's value.

<!--more-->

Let me demonstrate what I mean. In the recording below you can see how the type changes based on the "multiple" attribute.

::post-image{src="posts/1/code-example.gif" alt="Code example"}
::

How did I do this?

Typescript can automatically infer a generic type from a parameter in a generic function, this type can then be used to determine the type of another parameter or even the return type. When we combine this with conditional typing, we can create a generic function that returns a different value based on the parameter that is provided.

The generics in components work the same as in normal functions, therefore lets work out the example first in plain typescript before integrating it in our Vue component.

[You can also skip directly to the solution.](#final-solution)

```ts twoslash
// We infer the return type from the argument type.
function discovery<T>(arg: T): T {
  return arg;
}

// String in, string out
const result = discovery("Hello, World!" as string);
//    ^?
```

Now, lets reduce the possibilities to _true & false_ and create a conditional type for the result.

```ts twoslash
function discovery<T extends true | false>(multiple: T) {
  type ConditionalType = T extends true ? string[] : string;
  return (multiple ? [] : "") as ConditionalType;
}

// multiple = true
const multiple = discovery(true);
//    ^?

// multiple = false
const single = discovery(false);
//    ^?
```

This is great! But in a component we would also like to leave out the parameter (attribute) completely.

```vue
<!-- Like this -->
<MultiSelect ... />
<MultiSelect ... multiple />
```

Lets increase the usability of our function by allowing nothing to be specified. To do this we add a third option: undefined.

```ts twoslash
function discovery<T extends true | false>(multiple?: T) {
  type ConditionalType = undefined extends T
    ? string
    : T extends true
      ? string[]
      : string;
  return (multiple ? [] : "") as ConditionalType;
}

// multiple = true
const multiple = discovery(true);
//    ^?

// multiple = false
const single = discovery(false);
//    ^?

// multiple not present
const defaultSingle = discovery();
//    ^?
```

Do note: that we had to swap the check around when introducing undefined (_T extends undefined_ became _undefined extends T_)
If we didn't do this typescript returned both possibilities, in this case _string\[\] | string_.

### <span id="final-solution">Final solution: MultiSelect component</span>

Now that we've understood how to use conditional typing, lets translate this to a vue 3.3 component.

::code-group

```vue [MultiSelect.vue]
<script lang="ts">
// Export the type we would like to receive for the options.
export type KeyValue = { key: string; value: string };
</script>
<script lang="ts" setup generic="TMultiple extends true | false | undefined">
// Lets return the correct type based on the TMultiple value.
// - TMultiple === undefined => string
// - TMultiple === false => string
// - TMultiple === true => string[]
type TSingleOrMultiple = undefined extends TMultiple
  ? string
  : TMultiple extends false
    ? string
    : string[];

interface Props {
  modelValue?: TSingleOrMultiple;
  options?: KeyValue[];
  multiple?: TMultiple;
}

const props = defineProps<Props>();
const emit = defineEmits<{
  (e: "update:modelValue", value: TSingleOrMultiple): void;
}>();

// Also take into account that an empty attribute will result in a "" value
const isMultiple = computed(() => !isFalseOrUndefined(props.multiple));

const value = ref<any>(props.modelValue);
watch(value, (v) => emit("update:modelValue", v));
</script>

<template>
  <select v-model="value" :multiple="multiple">
    <option disabled value="">
      Please select {{ isMultiple ? "multiple" : "one" }}
    </option>
    <option v-for="{ key, value } in options" :value="key">
      {{ value }}
    </option>
  </select>
</template>
```

::post1-example1{label="Preview"}
::

::

### Bonus: PrimeVue MultiSelect

As a UI library I'm using PrimeVue. If we take their MultiSelect component, the modelValue is any.
Lets improve this as well and even add some extra "sugar" to add an optionValue allowing us to return what property of the option object to return.

::code-group

```vue [Example.vue]
<script lang="ts" setup>
import MultiSelect from "./MultiSelect.vue";
type Country = { id: number; key: string; value: string };
const countries: Country[] = [
  { id: 1, key: "United States", value: "US" },
  { id: 2, key: "Canada", value: "CA" },
  { id: 3, key: "United Kingdom", value: "GB" },
  { id: 4, key: "Australia", value: "AU" },
  { id: 5, key: "Germany", value: "DE" },
  { id: 6, key: "France", value: "FR" },
  { id: 7, key: "Japan", value: "JP" },
  { id: 8, key: "China", value: "CN" },
  { id: 9, key: "India", value: "IN" },
  { id: 10, key: "Brazil", value: "BR" },
  { id: 11, key: "Netherlands", value: "NL" },
];

const selectedCountry = ref<string | undefined>();
const selectedCountries = ref<number[]>([]);
</script>
<template>
  <p>
    <label>Single select</label>
    <MultiSelect
      :options="countries"
      v-model="selectedCountry"
      optionLabel="name"
      optionValue="key"
    />
    <span>Selected country: {{ selectedCountry }}</span>
  </p>
  <p>
    <label>Single select</label>
    <MultiSelect
      :options="countries"
      v-model="selectedCountries"
      optionLabel="name"
      optionValue="id"
      multiple
    />
    <span
      >Selected countries:
      <pre>{{ selectedCountries.join(", ") }}</pre>
    </span>
  </p>
</template>
```

```vue [MultiSelect.vue]
<script
  lang="ts"
  setup
  generic="
    TOptionType,
    TOptionValue extends keyof TOptionType,
    TMultiple extends true | false | undefined
  "
>
import MultiSelect, { type MultiSelectProps } from "primevue/multiselect";
import Select from "primevue/select";

type TSingleOrMultiple = undefined extends TMultiple
  ? TOptionType[TOptionValue]
  : TMultiple extends true
    ? TOptionType[TOptionValue][]
    : TOptionType[TOptionValue];

interface Props
  extends Omit<MultiSelectProps, "modelValue" | "options" | "optionValue"> {
  modelValue?: TSingleOrMultiple;
  optionValue?: TOptionValue;
  options?: TOptionType[];
  multiple?: TMultiple;
}

const props = defineProps<Props>();
const emit = defineEmits<{
  (e: "update:modelValue", value: TSingleOrMultiple): void;
}>();

// Also take into account that an empty attribute will result in a "" value
const isMultiple = computed(() => !isFalseOrUndefined(props.multiple));

const update = (value: any) => {
  emit("update:modelValue", value);
};
</script>

<template>
  <MultiSelect
    v-if="isMultiple"
    v-bind="props"
    :modelValue="modelValue"
    @update:modelValue="update"
  />
  <Select
    v-else
    v-bind="props"
    :modelValue="modelValue"
    @update:modelValue="update"
  />
</template>
```

::post1-example2{label="Preview"}
::

::
