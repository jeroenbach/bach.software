---
title: "Conditional property types by leveraging Vue 3.3 generics"
description: "Use Vue 3.3 generics to change the type of a property based on the value of another property."
category: Vue.js
keywords:
  - Vue.js
  - Generics
  - Conditional property type
authorName: jeroenbach
datePublished: 2024-11-05T08:00:00
dateModified: 2024-11-05T08:00:00
imgCoverUrl: /posts/1/cover.jpeg
readTime: 10 min
---

How can we change the type of a property based on the value of another property? Let's say, I want to return a single item by default and an array of items when the property `multiple` is defined.
Let me demonstrate what I mean.

In the recording below you can see how the type changes based on the `multiple` attribute.

<!--more-->

::post-image{src="posts/1/code-example.gif" alt="Code example"}
::

There are cases where you would like to re-use your component for multi and single values, but you don't want to introduce another property or emit (see as an example the BlogPostContext.vue within this [website project](https://github.com/jeroenbach/bach.software)).

Or what you could do with a Select/MultiSelect component, making it smarter and understand whether I'm returning an array when I specified `multiple` and a single item when I didn't. Read further on how I've managed to do this leveraging generics in Vue 3.3. Generics allowed me change a property type based on another property's value.

How did I do this?

Typescript can automatically infer a generic type from a parameter in a generic function, this type can then be used to determine the type of another parameter or even the return type. When we combine this with conditional typing, we can create a generic function that returns a different value based on the parameter that is provided.

The generics in components work the same as in normal functions, therefore lets work out the example first using plain typescript before integrating it in our Vue component.

[You can also go directly to the final solution.](#final-solution)

```ts twoslash
// We infer the return type from the argument type.
function discovery<T>(arg: T): T {
  return arg;
}

// String in, string out
const result = discovery("Hello, World!" as string);
//    ^?
```

Now, we can reduce the possibilities of this generic type by using `extends` and then create a new conditional type based on either one of these options. In the following example I'm reducing the possibilities to just `true` & `false` and return an array when `true` and a single value when `false`.

```ts twoslash
function discovery<T extends true | false>(multiple: T) {
  type ConditionalType = T extends true ? string[] : string;
  return (multiple ? [] : "") as ConditionalType;
}

// multiple = true
const multiple = discovery(true);
//    ^?

// multiple = false
const single = discovery(false);
//    ^?
```

This is great! When using this in a component, we would also like the option to omit the parameter (attribute) completely.

```vue
<!-- Like this -->
<MultiSelect ... />
<MultiSelect ... multiple />
```

Lets increase the usability of our function by allowing nothing to be specified. To do this we mark the argument as optional (?) and add a third option to our conditional type: undefined (which will result in the single item being returned).

```ts twoslash
function discovery<T extends true | false | undefined>(multiple?: T) {
  type ConditionalType = undefined extends T
    ? string
    : T extends false
      ? string
      : string[];
  return (multiple ? [] : "") as ConditionalType;
}

// multiple = true
const multiple = discovery(true);
//    ^?

// multiple = false
const single = discovery(false);
//    ^?

// multiple not present
const defaultSingle = discovery();
//    ^?
```

Do note: that we had to swap the check around when introducing undefined (`T extends undefined` became `undefined extends T`)
If we didn't do this typescript will return both possibilities, in this case `string\[\] | string`.

### <span id="final-solution">Final solution: Single-/MultiSelect component</span>

Now that we've understood how to use conditional typing, lets translate this to a vue 3.3 component.

::code-group

```vue [VSelect.vue]
<script lang="ts">
export type KeyValue = { key: string; value: string };
</script>
<script lang="ts" setup generic="TMultiple extends true | false | undefined">
// Lets return the correct type based on the TMultiple value.
// - TMultiple === undefined => string
// - TMultiple === false => string
// - TMultiple === true => string[]
type TSingleOrMultiple = undefined extends TMultiple
  ? string
  : TMultiple extends false
    ? string
    : string[];

interface Props {
  modelValue?: TSingleOrMultiple;
  options?: KeyValue[];
  multiple?: TMultiple;
}

const props = defineProps<Props>();
const emit = defineEmits<{
  (e: "update:modelValue", value: TSingleOrMultiple): void;
}>();

// Note: an empty attribute will result in an empty string "" value, therefore we check for false and undefined explicitly
const isMultiple = computed(() => !isFalseOrUndefined(props.multiple));

const value = ref<any>(props.modelValue);
watch(value, (v) => emit("update:modelValue", v));
</script>

<template>
  <select v-model="value" :multiple="multiple">
    <option disabled value="">
      Please select {{ isMultiple ? "multiple" : "one" }}
    </option>
    <option v-for="{ key, value } in options" :value="key">
      {{ value }}
    </option>
  </select>
</template>
```

::post1-example1{label="Preview"}
::

::

### Bonus: Advanced Select & MultiSelect component from PrimeVue

The UI library PrimeVue has both a Select and MultiSelect component, lets use what we've learned so far to combine them into one. Besides that, these components allow specifying any type of object array as the options, to allow this behavior they resolve this by making their modelValue of type any. Let's improve that as well and add some extra help choosing the optionValue property.

Here's an example of what we like to achieve:

::post-image{src="posts/1/code-example-2.gif" alt="Code example"}
::

To do this we performed the following steps:

- import both primevue components and show them based on the multiple property
- create a generic type that for the TOptionValue that is a keyof the TOptionType
  - note: that we couldn't use undefined here as the keyof would not be valid anymore, but we assigned it a default value of any
- then we create a TReturnType that returns either TOptionType or a property of it
- this TReturnType is then used to create a TSingleOrMultiple type based on the multiple property
- finally all these types are used in the props and emit to create all this extra help

::code-group

```vue [VSelect.vue]
<script
  lang="ts"
  setup
  generic="
    TOptionType,
    TOptionValue extends keyof TOptionType = any,
    TMultiple extends true | false = any
  "
>
import MultiSelect, { type MultiSelectProps } from "primevue/multiselect";
import Select from "primevue/select";

type TReturnType = undefined extends TOptionValue
  ? TOptionType
  : TOptionType[TOptionValue];

type TSingleOrMultiple = undefined extends TMultiple
  ? TReturnType
  : TMultiple extends false
    ? TReturnType
    : TReturnType[];

interface Props
  extends Omit<MultiSelectProps, "modelValue" | "options" | "optionValue"> {
  modelValue?: TSingleOrMultiple;
  optionValue?: TOptionValue;
  options?: TOptionType[];
  multiple?: TMultiple;
}

const props = defineProps<Props>();
const emit = defineEmits<{
  (e: "update:modelValue", value: TSingleOrMultiple): void;
}>();

// Also take into account that an empty attribute will result in a "" value
const isMultiple = computed(() => !isFalseOrUndefined(props.multiple));

const update = (value: any) => {
  emit("update:modelValue", value);
};
</script>

<template>
  <MultiSelect
    v-if="isMultiple"
    v-bind="props"
    :modelValue="modelValue"
    @update:modelValue="update"
  />
  <Select
    v-else
    v-bind="props"
    :modelValue="modelValue"
    @update:modelValue="update"
  />
</template>
```

```vue [Example.vue]
<script lang="ts" setup>
import VSelect from "./VSelect.vue";
type Country = { id: number; name: string; code: string };
const countries: Country[] = [
  { id: 1, name: "United States", code: "US" },
  { id: 2, name: "Canada", code: "CA" },
  { id: 3, name: "United Kingdom", code: "GB" },
  { id: 4, name: "Australia", code: "AU" },
  { id: 5, name: "Germany", code: "DE" },
  { id: 6, name: "France", code: "FR" },
  { id: 7, name: "Japan", code: "JP" },
  { id: 8, name: "China", code: "CN" },
  { id: 9, name: "India", code: "IN" },
  { id: 10, name: "Brazil", code: "BR" },
  { id: 11, name: "Netherlands", code: "NL" },
];

const selectedCountry = ref<string | undefined>();
const selectedCountries = ref<number[]>([]);
</script>
<template>
  <div class="form-field">
    <label>Single select</label>
    <VSelect
      :options="countries"
      v-model="selectedCountry"
      optionLabel="name"
      optionValue="code"
    />
    <span>
      Selected country:
      <pre>{{ selectedCountry }}</pre>
    </span>
  </div>
  <div class="form-field">
    <label>Multiple select</label>
    <VSelect
      :options="countries"
      v-model="selectedCountries"
      optionLabel="name"
      optionValue="id"
      multiple
    />
    <span>
      Selected countries:
      <pre>{{ selectedCountries.join(", ") }}</pre>
    </span>
  </div>
</template>
```

::post1-example2{label="Preview"}
::

::
